/* eslint-disable */
/**
 * This file was automatically generated by cartesapp.template_generator.
 * DO NOT MODIFY IT BY HAND. Instead, run the generator,
 */
import { ethers, Signer, ContractReceipt } from "ethers";

import { 
    advanceInput, inspect, 
    AdvanceOutput, InspectOptions, AdvanceInputOptions, GraphqlOptions,
    EtherDepositOptions, ERC20DepositOptions, ERC721DepositOptions,
    Report as CartesiReport, Notice as CartesiNotice, Voucher as CartesiVoucher, Input as CartesiInput,
    advanceDAppRelay, advanceERC20Deposit, advanceERC721Deposit, advanceEtherDeposit,
    queryNotice, queryReport, queryVoucher
} from "cartesi-client";


import Ajv from "ajv"
import addFormats from "ajv-formats"

import { 
    genericAdvanceInput, genericInspect, IOType, Models,
    IOData, Input, Output, Event, ContractCall, InspectReport, 
    MutationOptions, QueryOptions, 
    CONVENTIONAL_TYPES, decodeToConventionalTypes
} from "../cartesapp/utils"

import { 
    genericGetOutputs, decodeAdvance, DecodedIndexerOutput
} from "../cartesapp/lib"

import * as indexerIfaces from "../indexer/ifaces"
import * as ifaces from "./ifaces";


/**
 * Configs
 */

const ajv = new Ajv();
addFormats(ajv);
ajv.addFormat("biginteger", (data) => {
    const dataTovalidate = data.startsWith('-') ? data.substring(1) : data;
    return ethers.utils.isHexString(dataTovalidate) && dataTovalidate.length % 2 == 0;
});
const MAX_SPLITTABLE_OUTPUT_SIZE = 4194247;

/*
 * Mutations/Advances
 */


/*
 * Queries/Inspects
 */


/*
 * Indexer Query
 */

export async function getOutputs(
    inputData: indexerIfaces.IndexerPayload,
    options?:InspectOptions
):Promise<DecodedIndexerOutput> {
    return genericGetOutputs(inputData,decodeToModel,options);
}


/**
 * Models Decoders/Exporters
 */

export function decodeToModel(data: CartesiReport | CartesiNotice | CartesiVoucher | InspectReport | CartesiInput, modelName: string): any {
    if (modelName == undefined)
        throw new Error("undefined model");
    if (CONVENTIONAL_TYPES.includes(modelName))
        return decodeToConventionalTypes(data.payload,modelName);
    const decoder = models[modelName].decoder;
    if (decoder == undefined)
        throw new Error("undefined decoder");
    return decoder(data);
}

export function exportToModel(data: any, modelName: string): string {
    const exporter = models[modelName].exporter;
    if (exporter == undefined)
        throw new Error("undefined exporter");
    return exporter(data);
}

export class NftOutputExtension extends Event<ifaces.NftOutputExtension> { constructor(output: CartesiNotice) { super(models['NftOutputExtension'],output); } }
export function decodeToNftOutputExtension(output: CartesiReport | CartesiNotice | CartesiVoucher | InspectReport | CartesiInput): NftOutputExtension {
    return new NftOutputExtension(output as CartesiNotice);
}

export class VerificationOutput extends Event<ifaces.VerificationOutput> { constructor(output: CartesiNotice) { super(models['VerificationOutput'],output); } }
export function decodeToVerificationOutput(output: CartesiReport | CartesiNotice | CartesiVoucher | InspectReport | CartesiInput): VerificationOutput {
    return new VerificationOutput(output as CartesiNotice);
}


/**
 * Model
 */

export const models: Models = {
    'NftOutputExtension': {
        ioType:IOType.notice,
        abiTypes:['bytes32', 'string'],
        params:['tape_hash', 'cid'],
        decoder: decodeToNftOutputExtension,
        validator: ajv.compile<ifaces.NftOutputExtension>(JSON.parse('{"title": "NftOutputExtension", "type": "object", "properties": {"tape_hash": {"type": "string", "format": "binary"}, "cid": {"type": "string"}}, "required": ["tape_hash", "cid"]}'.replaceAll('integer','string","format":"biginteger')))
    },
    'VerificationOutput': {
        ioType:IOType.notice,
        abiTypes:['bytes32', 'bytes32', 'int', 'address', 'uint', 'int', 'bytes32', 'int', 'bytes32', 'int', 'address', 'uint', 'bytes'],
        params:['version', 'cartridge_id', 'cartridge_input_index', 'cartridge_user_address', 'timestamp', 'score', 'rule_id', 'rule_input_index', 'tape_hash', 'tape_input_index', 'user_address', 'error_code', 'nft_output'],
        decoder: decodeToVerificationOutput,
        validator: ajv.compile<ifaces.VerificationOutput>(JSON.parse('{"title": "VerificationOutput", "type": "object", "properties": {"version": {"type": "string", "format": "binary"}, "cartridge_id": {"type": "string", "format": "binary"}, "cartridge_input_index": {"type": "integer"}, "cartridge_user_address": {"type": "string"}, "timestamp": {"type": "integer"}, "score": {"type": "integer"}, "rule_id": {"type": "string", "format": "binary"}, "rule_input_index": {"type": "integer"}, "tape_hash": {"type": "string", "format": "binary"}, "tape_input_index": {"type": "integer"}, "user_address": {"type": "string"}, "error_code": {"type": "integer"}, "nft_output": {"type": "string", "format": "binary"}}, "required": ["version", "cartridge_id", "cartridge_input_index", "cartridge_user_address", "timestamp", "score", "rule_id", "rule_input_index", "tape_hash", "tape_input_index", "user_address", "error_code", "nft_output"]}'.replaceAll('integer','string","format":"biginteger')))
    },
    };